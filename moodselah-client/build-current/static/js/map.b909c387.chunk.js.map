{"version":3,"sources":["components/MapPlaceModal/MapPlaceModal.module.scss","components/Map/Map.module.scss","components/MapPlaceModal/index.tsx","components/MapPlaceModal/MapPlaceModal.tsx","components/Map/Map.tsx","components/Map/index.tsx","routes/Map/Map.module.scss","routes/Map/queries.ts","routes/Map/Map.tsx","routes/Map/index.tsx"],"names":["module","exports","container","contentContainer","closeContainer","btnClose","info","title","btnContainer","btnLink","photos","MapPlaceModal","React","props","react","Modal_default","a","open","isVisible","onClose","className","s","type","onClick","children","settings","dots","infinite","speed","autoplay","slidesToShow","slidesToScroll","prevArrow","_ref","style","Object","objectSpread","left","zIndex","display","indexOf","nextArrow","_ref2","right","Map","ref","mapRef","classNames","components_MapPlaceModal","onCloseMapPlaceModal","isVisiblePlaceInfo","place","address","href","concat","lat","lng","target","lib_default","map","photo","key","path","postId","src","MapContainer","marker","geocoder","clusterer","state","document","getElementById","this","onInit","script","createElement","onload","daum","maps","load","_this2","id","body","appendChild","prevProps","setMinMax","updateData","updateCenter","updateMarkerFromDetailAddr","getCurrentLocation","center","initialOption","_this$props$initialOp","initialCenter","initialLevel","level","current","LatLng","services","Geocoder","readOnly","data","length","Marker","setMap","mapTypeControl","MapTypeControl","addControl","ControlPosition","TOPRIGHT","zoomControl","ZoomControl","RIGHT","setZoomable","registerMarkers","registerSubscribes","_this3","clear","MarkerClusterer","averageCenter","minLevel","markers","position","posts","flatMap","post","event","addListener","setState","addMarkers","_this4","onMapReady","region","onChangeRegion","onChangeRegionComplete","e","searchDetailAddrFromCoords","latLng","result","status","Status","OK","roadAddr","road_address","address_name","jibunAddr","setPosition","onChangeMarkerPosition","getLat","getLng","searchCoordFromDetailAddr","Promise","resolve","reject","navigator","geolocation","getCurrentPosition","coords","latitude","longitude","error","Error","isEqual","setCenter","maxZoomLevel","setMinLevel","minZoomLevel","setMaxLevel","callback","coord2Address","_this5","addressSearch","y","x","Map_Map","assign","bounds","matchBoundsKey","getBounds","zoomLevel","getLevel","mathCenterKey","getCenter","swLatLng","getSouthWest","neLatLng","getNorthEast","n","w","defaultProps","autobind","GET_PLACES","gql","_templateObject","i18n","loading","_ref$GetPlaces","GetPlaces","_ref$GetPlaces$places","places","Helmet_default","t","components_Map","GetPlacesQuery","Query","fetchMore","isInfiniteScroll","isFinishedLoadMore","undefined","variables","updateQuery","prev","fetchMoreResult","_region$center","onLoadMore","_this$state","Map_GetPlacesQuery","query","_ref3","routes_Map_Map"],"mappings":"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","file":"static/js/map.b909c387.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"MapPlaceModal_container__1IjZ3\",\"contentContainer\":\"MapPlaceModal_contentContainer__WX-TC\",\"closeContainer\":\"MapPlaceModal_closeContainer__aP5Mh\",\"btnClose\":\"MapPlaceModal_btnClose__12qcH\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"info\":\"Map_info__13daX\",\"title\":\"Map_title__mwyY4\",\"btnContainer\":\"Map_btnContainer__2jQ7p\",\"btnLink\":\"Map_btnLink__W2ZXR\",\"photos\":\"Map_photos__3KYHH\"};","import MapPlaceModal from './MapPlaceModal';\n\nexport default MapPlaceModal;\n","import * as React from 'react';\nimport Modal from '@material-ui/core/Modal';\nimport s from './MapPlaceModal.module.scss';\n\nexport interface MapPlaceModalProps {\n  children: any;\n  isVisible: boolean;\n  onClose: () => void;\n}\n\nconst MapPlaceModal: React.SFC<MapPlaceModalProps> = React.memo(props => {\n  return (\n    <Modal open={props.isVisible} onClose={props.onClose}>\n      <div className={s.container}>\n        <div className={s.closeContainer}>\n          <button className={s.btnClose} type=\"button\" onClick={props.onClose}>\n            x\n          </button>\n        </div>\n        <div className={s.contentContainer}>{props.children}</div>\n      </div>\n    </Modal>\n  );\n});\n\nexport default MapPlaceModal;\n","import * as React from 'react';\nimport { Link } from 'react-router-dom';\nimport Slider from 'react-slick';\nimport classNames from 'classnames';\nimport MapPlaceModal from '../MapPlaceModal';\nimport s from './Map.module.scss';\n\ninterface IProps {\n  mapRef: React.RefObject<HTMLDivElement>;\n  className?: any;\n  onCloseMapPlaceModal: any;\n  place: any;\n  isVisiblePlaceInfo: boolean;\n}\n\ninterface IArrowProps {\n  className?: any;\n  style?: any;\n  onClick?: any;\n}\n\nconst SliderPrevArrow: React.SFC<IArrowProps> = ({ className, style, onClick }) => (\n  <div\n    className={className}\n    style={{\n      ...style,\n      left: '16px',\n      zIndex: 10,\n      display: className.indexOf('disable') !== -1 ? 'none' : 'block'\n    }}\n    onClick={onClick}\n  />\n);\n\nconst SliderNextArrow: React.SFC<IArrowProps> = ({ className, style, onClick }) => (\n  <div\n    className={className}\n    style={{\n      ...style,\n      right: '16px',\n      zIndex: 10,\n      display: className.indexOf('disable') !== -1 ? 'none' : 'block'\n    }}\n    onClick={onClick}\n  />\n);\n\nconst settings = {\n  dots: true,\n  infinite: false,\n  speed: 500,\n  autoplay: false,\n  slidesToShow: 4,\n  slidesToScroll: 4,\n  prevArrow: <SliderPrevArrow />,\n  nextArrow: <SliderNextArrow />\n};\n\nconst Map: React.SFC<IProps> = React.memo(props => (\n  <>\n    <div ref={props.mapRef} className={classNames(props.className)} />\n    <MapPlaceModal onClose={props.onCloseMapPlaceModal} isVisible={props.isVisiblePlaceInfo}>\n      {props.place ? (\n        <div className={s.info}>\n          <h2 className={s.title}>{props.place.address}</h2>\n          <div className={s.btnContainer}>\n            <a\n              className={s.btnLink}\n              href={`http://map.daum.net/link/map/${props.place.address},${props.place.lat},${props.place.lng}`}\n              target=\"_blank\"\n            >\n              큰지도보기\n            </a>\n            <a\n              className={s.btnLink}\n              href={`http://map.daum.net/link/to/${props.place.address},${props.place.lat},${props.place.lng}`}\n              target=\"_blank\"\n            >\n              길찾기\n            </a>\n          </div>\n          <div className={s.photos}>\n            <Slider {...settings}>\n              {props.place.photos.map(photo => (\n                <a key={photo.path} href={`/posts/${photo.postId}`}>\n                  <img src={photo.path} />\n                </a>\n              ))}\n            </Slider>\n          </div>\n        </div>\n      ) : null}\n    </MapPlaceModal>\n  </>\n));\n\nexport default Map;\n","import * as React from 'react';\nimport isEqual from 'lodash-es/isEqual';\nimport autobind from 'autobind-decorator';\nimport Map from './Map';\n\ndeclare const daum: any;\n\ntype latLng = { roadAddr?: string; jibunAddr?: string; lat: number; lng: number };\ntype bounds = { n: number; e: number; s: number; w: number };\n\ntype mapPositionInfo = {\n  bounds: bounds;\n  zoomLevel: number;\n  center: latLng;\n};\n\nexport interface IProps {\n  className?: string;\n  initialOption?: { center?: latLng; level?: number };\n  maxZoomLevel?: number;\n  minZoomLevel?: number;\n  onMapReady?: (info: mapPositionInfo) => void;\n  onChangeRegion?: (info: mapPositionInfo) => void;\n  onChangeRegionComplete?: (info: mapPositionInfo) => void;\n  onChangeMarkerPosition?: (position: latLng) => void;\n  center?: { lat: number; lng: number };\n  address?: string;\n  data: any | null;\n  readOnly?: boolean;\n}\n\nexport interface IState {\n  place: any;\n  isVisiblePlaceInfo: boolean;\n}\n\nclass MapContainer extends React.PureComponent<IProps, IState> {\n  static defaultProps = {\n    onMapReady: () => {},\n    onChangeRegion: () => {},\n    onChangeRegionComplete: () => {},\n    onChangeMarkerPosition: () => {},\n    data: [],\n    readOnly: false\n  };\n\n  private mapRef: React.RefObject<HTMLDivElement> = React.createRef();\n  private map: any;\n  private marker: any;\n  private geocoder: any;\n  private clusterer: any;\n\n  public state: IState = {\n    place: null,\n    isVisiblePlaceInfo: false\n  };\n\n  static matchBoundsKey(bounds) {\n    const swLatLng = bounds.getSouthWest();\n    const neLatLng = bounds.getNorthEast();\n    return { n: neLatLng.getLat(), e: neLatLng.getLng(), s: swLatLng.getLat(), w: swLatLng.getLng() };\n  }\n\n  static mathCenterKey(center) {\n    return { lat: center.getLat(), lng: center.getLng() };\n  }\n\n  public async componentDidMount() {\n    const scriptId = 'kakao_map';\n    const isExist = !!document.getElementById(scriptId);\n\n    if (!isExist) {\n      const script = document.createElement('script');\n      script.src =\n        '//dapi.kakao.com/v2/maps/sdk.js?appkey=128a2da1935ecfc8ce068ce4e4fe0d7d&libraries=services,clusterer,drawing&autoload=false';\n      script.onload = () => daum.maps.load(() => this.onInit());\n      script.id = scriptId;\n      document.body.appendChild(script);\n    } else {\n      this.onInit();\n    }\n  }\n\n  public componentDidUpdate(prevProps) {\n    this.setMinMax();\n    this.updateData(prevProps);\n    this.updateCenter(prevProps);\n    this.updateMarkerFromDetailAddr(prevProps);\n  }\n\n  get region() {\n    return {\n      bounds: MapContainer.matchBoundsKey(this.map.getBounds()),\n      zoomLevel: this.map.getLevel(),\n      center: MapContainer.mathCenterKey(this.map.getCenter())\n    };\n  }\n\n  private async onInit() {\n    let center: latLng | undefined;\n    let level: number | undefined;\n    try {\n      center = await this.getCurrentLocation();\n    } catch (e) {\n      // nothing to do\n    }\n    if (this.props.initialOption) {\n      const { center: initialCenter, level: initialLevel } = this.props.initialOption;\n      initialCenter && (center = initialCenter);\n      initialLevel && (level = initialLevel);\n    }\n    const { lat, lng } = center || { lat: 37.566826, lng: 126.9786567 }; // default: 서울시청\n\n    // 지도를 생성합니다\n    this.map = new daum.maps.Map(this.mapRef.current, {\n      center: new daum.maps.LatLng(lat, lng),\n      level\n    });\n\n    // 주소-좌표 변환 객체를 생성합니다\n    this.geocoder = new daum.maps.services.Geocoder();\n\n    if (!this.props.readOnly && (!this.props.data || !this.props.data.length)) {\n      // 지도를 클릭한 위치에 표출할 마커입니다\n      this.marker = new daum.maps.Marker();\n      // 지도에 마커를 표시합니다\n      this.marker.setMap(this.map);\n    }\n\n    // 일반 지도와 스카이뷰로 지도 타입을 전환할 수 있는 지도타입 컨트롤을 생성합니다\n    const mapTypeControl = new daum.maps.MapTypeControl();\n\n    // 지도에 컨트롤을 추가해야 지도위에 표시됩니다\n    // daum.maps.ControlPosition은 컨트롤이 표시될 위치를 정의하는데 TOPRIGHT는 오른쪽 위를 의미합니다\n    this.map.addControl(mapTypeControl, daum.maps.ControlPosition.TOPRIGHT);\n\n    // 지도 확대 축소를 제어할 수 있는  줌 컨트롤을 생성합니다\n    const zoomControl = new daum.maps.ZoomControl();\n    this.map.addControl(zoomControl, daum.maps.ControlPosition.RIGHT);\n    this.map.setZoomable(false);\n\n    this.registerMarkers();\n    this.registerSubscribes();\n  }\n\n  private registerMarkers() {\n    if (!this.props.data) {\n      return;\n    }\n    if (!this.clusterer) {\n      // 마커 클러스터러를 생성합니다\n      this.clusterer = new daum.maps.MarkerClusterer({\n        map: this.map, // 마커들을 클러스터로 관리하고 표시할 지도 객체\n        averageCenter: true, // 클러스터에 포함된 마커들의 평균 위치를 클러스터 마커 위치로 설정\n        minLevel: 10 // 클러스터 할 최소 지도 레벨\n      });\n    } else {\n      this.clusterer.clear();\n    }\n    const markers = this.props.data.map(data => {\n      const position = new daum.maps.LatLng(data.lat, data.lng);\n      const marker = new daum.maps.Marker({\n        position\n      });\n      const photos = (data.posts || []).flatMap(post => post.photos.map(photo => ({ ...photo, postId: post.id })));\n      // 마커에 클릭이벤트를 등록합니다\n      daum.maps.event.addListener(marker, 'click', () => {\n        this.setState({\n          isVisiblePlaceInfo: true,\n          place: {\n            ...data,\n            photos\n          }\n        });\n      });\n      return marker;\n    });\n    // 클러스터러에 마커들을 추가합니다\n    this.clusterer.addMarkers(markers);\n  }\n\n  private registerSubscribes() {\n    this.setMinMax();\n    this.props.onMapReady && this.props.onMapReady(this.region);\n    daum.maps.event.addListener(this.map, 'bounds_changed', () => {\n      this.props.onChangeRegion && this.props.onChangeRegion(this.region);\n    });\n    daum.maps.event.addListener(this.map, 'idle', () => {\n      this.props.onChangeRegionComplete && this.props.onChangeRegionComplete(this.region);\n    });\n    // 지도에 클릭 이벤트를 등록합니다\n    // 지도를 클릭하면 마지막 파라미터로 넘어온 함수를 호출합니다\n    daum.maps.event.addListener(this.map, 'click', e => {\n      if (!this.marker) {\n        return;\n      }\n      // 클릭한 위도, 경도 정보를 가져옵니다\n      this.searchDetailAddrFromCoords(e.latLng, (result, status) => {\n        if (status === daum.maps.services.Status.OK) {\n          const roadAddr = !!result[0].road_address ? result[0].road_address.address_name : '';\n          const jibunAddr = result[0].address.address_name;\n\n          // 마커를 클릭한 위치에 표시합니다\n          this.marker.setPosition(e.latLng);\n          this.marker.setMap(this.map);\n\n          if (this.props.onChangeMarkerPosition) {\n            this.props.onChangeMarkerPosition({\n              roadAddr,\n              jibunAddr,\n              lat: e.latLng.getLat(),\n              lng: e.latLng.getLng()\n            });\n          }\n        }\n      });\n    });\n\n    if (this.props.address) {\n      this.searchCoordFromDetailAddr(this.props.address);\n    }\n  }\n\n  private getCurrentLocation(): Promise<latLng> {\n    return new Promise((resolve, reject) => {\n      if ('geolocation' in navigator) {\n        navigator.geolocation.getCurrentPosition(\n          position => {\n            resolve({\n              lat: position.coords.latitude,\n              lng: position.coords.longitude\n            });\n          },\n          error => {\n            // error.code can be:\n            //   0: unknown error\n            //   1: permission denied\n            //   2: position unavailable (error response from location provider)\n            //   3: timed out\n            reject(error);\n          }\n        );\n      } else {\n        reject(new Error('not supported geolocation.'));\n      }\n    });\n  }\n\n  private updateData(prevProps) {\n    if (prevProps.data !== this.props.data) {\n      this.registerMarkers();\n    }\n  }\n\n  private updateCenter(prevProps) {\n    const { center } = this.props;\n    if (center && !isEqual(prevProps.center, center)) {\n      this.map.setCenter(new daum.maps.LatLng(center.lat, center.lng));\n    }\n  }\n\n  private updateMarkerFromDetailAddr(prevProps) {\n    if (prevProps.address !== this.props.address) {\n      this.searchCoordFromDetailAddr(this.props.address);\n    }\n  }\n\n  private setMinMax() {\n    if (this.map) {\n      this.props.maxZoomLevel && this.map.setMinLevel(this.props.maxZoomLevel);\n      this.props.minZoomLevel && this.map.setMaxLevel(this.props.minZoomLevel);\n    }\n  }\n\n  private searchDetailAddrFromCoords(coords, callback) {\n    // 좌표로 법정동 상세 주소 정보를 요청합니다\n    this.geocoder.coord2Address(coords.getLng(), coords.getLat(), callback);\n  }\n\n  private searchCoordFromDetailAddr(address) {\n    this.geocoder.addressSearch(address, (result, status) => {\n      // 정상적으로 검색이 완료됐으면\n      if (status === daum.maps.services.Status.OK) {\n        const coords = new daum.maps.LatLng(result[0].y, result[0].x);\n        // 클릭한 위도, 경도 정보를 가져옵니다\n        this.searchDetailAddrFromCoords(coords, (result, status) => {\n          if (status === daum.maps.services.Status.OK) {\n            const roadAddr = !!result[0].road_address ? result[0].road_address.address_name : '';\n            const jibunAddr = result[0].address.address_name;\n\n            // 마커를 클릭한 위치에 표시합니다\n            this.marker.setPosition(coords);\n            this.map.setCenter(coords);\n\n            if (this.props.onChangeMarkerPosition) {\n              this.props.onChangeMarkerPosition({\n                roadAddr,\n                jibunAddr,\n                lat: coords.getLat(),\n                lng: coords.getLng()\n              });\n            }\n          }\n        });\n      }\n    });\n  }\n\n  @autobind\n  private onCloseMapPlaceModal() {\n    this.setState({ isVisiblePlaceInfo: false });\n  }\n\n  public render() {\n    return (\n      <Map {...this.props} {...this.state} mapRef={this.mapRef} onCloseMapPlaceModal={this.onCloseMapPlaceModal} />\n    );\n  }\n}\n\nexport default MapContainer;\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"Map_container__1I5H5\",\"map\":\"Map_map__QCdvM\"};","import { gql } from 'apollo-boost';\n\nexport const GET_PLACES = gql`\n  query getPlaces($lat: Float!, $lng: Float!, $where: String) {\n    GetPlaces(lat: $lat, lng: $lng, where: $where) {\n      success\n      error\n      places {\n        id\n        address\n        lat\n        lng\n        posts {\n          id\n          content\n          photos {\n            id\n            path\n          }\n        }\n      }\n    }\n  }\n`;\n","import * as React from 'react';\nimport Helmet from 'react-helmet';\nimport KakaoMap from '~/components/Map';\nimport i18n from '~/helpers/i18n';\nimport s from './Map.module.scss';\nimport { getPlaces } from '~/types/api';\n\ninterface IProps {\n  t: (keyword: string) => string;\n  loading: boolean;\n  data: getPlaces | undefined;\n  onChangeRegionComplete: (region: any) => void;\n}\n\nconst Map: React.SFC<IProps> = props => {\n  if (props.loading) {\n    return null;\n  }\n  const { GetPlaces: { places = null } = {} } = props.data || {};\n  if (!places) {\n    return null;\n  }\n  return (\n    <>\n      <Helmet>\n        <title>{props.t('map.title')} - Moodselah</title>\n      </Helmet>\n      <div className={s.container}>\n        <KakaoMap\n          className={s.map}\n          initialOption={{ level: 5 }}\n          data={places}\n          readOnly={true}\n          onChangeRegionComplete={props.onChangeRegionComplete}\n        />\n      </div>\n    </>\n  );\n};\n\nexport default i18n(Map);\n","import * as React from 'react';\nimport { Query } from 'react-apollo';\nimport autobind from 'autobind-decorator';\nimport { getPlaces } from '~/types/api';\nimport { GET_PLACES } from './queries';\nimport Map from './Map';\n\ntype latLng = {\n  lat: number;\n  lng: number;\n};\n\nexport interface IProps {}\n\nexport interface IState {\n  isInfiniteScroll: boolean;\n  isFinishedLoadMore: boolean;\n  lat?: number;\n  lng?: number;\n}\n\nclass GetPlacesQuery extends Query<getPlaces> {}\n\nclass MapContainer extends React.Component<IProps, IState> {\n  fetchMore: any;\n  state: IState = {\n    isInfiniteScroll: false,\n    isFinishedLoadMore: false,\n    lat: undefined,\n    lng: undefined\n  };\n\n  async componentDidMount() {\n    let center: latLng | undefined;\n    try {\n      center = await this.getCurrentLocation();\n    } catch (e) {\n      // nothing to do\n    }\n    const { lat, lng } = center || { lat: 37.566826, lng: 126.9786567 }; // default: 서울시청\n    this.setState({ lat, lng });\n  }\n\n  @autobind\n  private onLoadMore(lat: number, lng: number) {\n    if (!this.fetchMore) return;\n    this.fetchMore({\n      variables: {\n        lat,\n        lng\n      },\n      updateQuery: (prev, { fetchMoreResult }) => {\n        if (!fetchMoreResult) return prev;\n        return fetchMoreResult;\n      }\n    });\n  }\n\n  @autobind\n  private onChangeRegionComplete(region) {\n    const { lat, lng } = region.center;\n    this.onLoadMore(lat, lng);\n  }\n\n  @autobind\n  private getCurrentLocation(): Promise<latLng> {\n    return new Promise((resolve, reject) => {\n      if ('geolocation' in navigator) {\n        navigator.geolocation.getCurrentPosition(\n          position => {\n            resolve({\n              lat: position.coords.latitude,\n              lng: position.coords.longitude\n            });\n          },\n          error => {\n            // error.code can be:\n            //   0: unknown error\n            //   1: permission denied\n            //   2: position unavailable (error response from location provider)\n            //   3: timed out\n            reject(error);\n          }\n        );\n      } else {\n        reject(new Error('not supported geolocation.'));\n      }\n    });\n  }\n\n  public render() {\n    const { lat, lng } = this.state;\n    if (!lat || !lng) {\n      return null;\n    }\n    return (\n      <GetPlacesQuery query={GET_PLACES} variables={{ lat, lng }}>\n        {({ data, fetchMore, loading }) => {\n          this.fetchMore = fetchMore;\n          return (\n            <Map\n              {...this.state}\n              {...this.props}\n              loading={loading}\n              data={data}\n              onChangeRegionComplete={this.onChangeRegionComplete}\n            />\n          );\n        }}\n      </GetPlacesQuery>\n    );\n  }\n}\n\nexport default MapContainer;\n"],"sourceRoot":""}